

## Optional

**Report your browser version, CPU type, cache size, RAM amount, and OS. We use this information to learn about the attack’s behavior on different machines.**

- Browser:
- CPU:
- Cache sizes:
- RAM:
- OS:




## 1-2

**Use the values printed on the webpage to find the median access time and report your results as follows.**

| Number of Cache Lines | Median Access Latency (ms) |
| --------------------- | -------------------------- |
| 1                     |                            |
| 10                    |                            |
| 100                   |                            |
| 1,000                 |                            |
| 10,000                |                            |
| 100,000               |                            |
| 1,000,000             |                            |
| 10,000,000            |                            |




## 1-3

**According to your measurement results, what is the resolution of your `performance.now()`? In order to measure differences in time with `performance.now()``, approximately how many cache accesses need to be performed?**




## 2-2

**Report important parameters used in your attack. For each sweep operation, you access N addresses, and you count the number of sweep operations within a time interval P ms. What values of N and P do you use? How do you choose N? Why do not you choose P to be larger or smaller?**

We used N = 1,000,000 cache lines per sweep and P = 20 ms for the time window. N is the number of addresses we touch in one full sweep over the buffer; I chose it so the buffer is large enough to interact with the last-level cache and so one sweep takes on the order of tens of milliseconds, which gives a useful sweep count per window and a clear difference between idle and victim-active traces. If N were too large we'd get almost no sweeps per window, and if it were too small the counts would be noisier. For P, I didn't go larger because that would give fewer trace points (K = 5000/P) and we'd lose resolution over the 5 seconds, and I didn't go smaller because then each window would be so short that the sweep count per window would be noisier and we might only get 0 or 1 sweep per window, which isn't useful. So P around 20 ms gives a good balance: enough trace points (250) and a stable sweep count per window.




## 2-3

**Take screenshots of the three traces generated by your attack code and include them in the lab report.**

![Screenshot of traces](./part2/Screenshot.png)




## 2-4

**Use the Python code we provided in Part 2.1 to analyze simple statistics (mean, median, etc.) on the traces from google.com and nytimes.com. Report the statistic numbers.**




## 2-6

**Include your classification results in your report.**

```
                          precision    recall  f1-score   support

https://www.facebook.com       0.97      0.97      0.97        33
  https://www.google.com       0.97      0.97      0.97        39
 https://www.nytimes.com       0.96      1.00      0.98        52
 https://www.youtube.com       1.00      0.94      0.97        36

                accuracy                           0.97       160
               macro avg       0.98      0.97      0.97       160
            weighted avg       0.98      0.97      0.97       160
```




## 3-2

**Include your new accuracy results for the modified attack code in your report.**

```
                          precision    recall  f1-score   support

https://www.facebook.com       0.81      0.77      0.79        44
  https://www.google.com       0.71      0.73      0.72        37
 https://www.nytimes.com       0.95      1.00      0.98        40
 https://www.youtube.com       0.92      0.90      0.91        39

                accuracy                           0.85       160
               macro avg       0.85      0.85      0.85       160
            weighted avg       0.85      0.85      0.85       160

```




## 3-3

**Compare your accuracy numbers between Part 2 and 3. Does the accuracy decrease in Part 3? Do you think that our “cache-occupancy” attack actually exploits a cache side channel? If not, take a guess as to possible root causes of the modified attack.**

